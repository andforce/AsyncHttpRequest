
task androidJavadoc(type: Javadoc/*, dependsOn: assembleDebug*/) {
    source += files(android.sourceSets.main.java.srcDirs)
    classpath += files(android.bootClasspath)

    android.libraryVariants.all { variant ->
        def name = variant.name.capitalize()
        task "jar${name}"(type: Jar, dependsOn: variant.javaCompileProvider) {
            from it.destinationDir
        }

        androidJavadoc.classpath += files(it.classpath.files)
        // This is generated by `assembleDebug` and holds the JARs generated by the APT.
        androidJavadoc.classpath += fileTree(dir: "$buildDir/intermediates/bundles/debug/", include: '**/*.jar')

        // Process AAR dependencies
        def aarDependencies = classpath.filter { it.name.endsWith('.aar') }
        classpath -= aarDependencies
        aarDependencies.each { aar ->
            // Extract classes.jar from the AAR dependency, and add it to the javadoc classpath
            def outputPath = "$buildDir/tmp/aarJar/${aar.name.replace('.aar', '.jar')}"
            classpath += files(outputPath)

            // Use a task so the actual extraction only happens before the javadoc task is run
            dependsOn task(name: "extract ${aar.name}").doLast {
                extractEntry(aar, 'classes.jar', outputPath)
            }
        }
    }

    failOnError false
    // This task will try to compile *everything* it finds in the above directory and
    // will choke on text files it doesn't understand.
    exclude '**/BUCK'
    exclude '**/*.md'
}

task androidJavadocJar(type: Jar, dependsOn: androidJavadoc) {
    classifier = 'javadoc'
    from androidJavadoc.destinationDir
}

task androidSourcesJar(type: Jar) {
    classifier = 'sources'
    from android.sourceSets.main.java.srcDirs
}

artifacts.add('archives', androidJavadocJar)
artifacts.add('archives', androidSourcesJar)